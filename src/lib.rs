#![doc = "Peripheral access API for XMC4300 microcontrollers (generated using svd2rust v0.33.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.33.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 6;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn SCU_0();
    fn ERU0_0();
    fn ERU0_1();
    fn ERU0_2();
    fn ERU0_3();
    fn ERU1_0();
    fn ERU1_1();
    fn ERU1_2();
    fn ERU1_3();
    fn PMU0_0();
    fn VADC0_C0_0();
    fn VADC0_C0_1();
    fn VADC0_C0_2();
    fn VADC0_C0_3();
    fn VADC0_G0_0();
    fn VADC0_G0_1();
    fn VADC0_G0_2();
    fn VADC0_G0_3();
    fn VADC0_G1_0();
    fn VADC0_G1_1();
    fn VADC0_G1_2();
    fn VADC0_G1_3();
    fn DAC0_0();
    fn DAC0_1();
    fn CCU40_0();
    fn CCU40_1();
    fn CCU40_2();
    fn CCU40_3();
    fn CCU41_0();
    fn CCU41_1();
    fn CCU41_2();
    fn CCU41_3();
    fn CCU80_0();
    fn CCU80_1();
    fn CCU80_2();
    fn CCU80_3();
    fn CAN0_0();
    fn CAN0_1();
    fn CAN0_2();
    fn CAN0_3();
    fn CAN0_4();
    fn CAN0_5();
    fn CAN0_6();
    fn CAN0_7();
    fn USIC0_0();
    fn USIC0_1();
    fn USIC0_2();
    fn USIC0_3();
    fn USIC0_4();
    fn USIC0_5();
    fn USIC1_0();
    fn USIC1_1();
    fn USIC1_2();
    fn USIC1_3();
    fn USIC1_4();
    fn USIC1_5();
    fn LEDTS0_0();
    fn FCE0_0();
    fn GPDMA0_0();
    fn SDMMC0_0();
    fn USB0_0();
    fn ETH0_0();
    fn ECAT0_0();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 110] = [
    Vector { _handler: SCU_0 },
    Vector { _handler: ERU0_0 },
    Vector { _handler: ERU0_1 },
    Vector { _handler: ERU0_2 },
    Vector { _handler: ERU0_3 },
    Vector { _handler: ERU1_0 },
    Vector { _handler: ERU1_1 },
    Vector { _handler: ERU1_2 },
    Vector { _handler: ERU1_3 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: PMU0_0 },
    Vector { _reserved: 0 },
    Vector { _handler: VADC0_C0_0 },
    Vector { _handler: VADC0_C0_1 },
    Vector { _handler: VADC0_C0_2 },
    Vector { _handler: VADC0_C0_3 },
    Vector { _handler: VADC0_G0_0 },
    Vector { _handler: VADC0_G0_1 },
    Vector { _handler: VADC0_G0_2 },
    Vector { _handler: VADC0_G0_3 },
    Vector { _handler: VADC0_G1_0 },
    Vector { _handler: VADC0_G1_1 },
    Vector { _handler: VADC0_G1_2 },
    Vector { _handler: VADC0_G1_3 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: DAC0_0 },
    Vector { _handler: DAC0_1 },
    Vector { _handler: CCU40_0 },
    Vector { _handler: CCU40_1 },
    Vector { _handler: CCU40_2 },
    Vector { _handler: CCU40_3 },
    Vector { _handler: CCU41_0 },
    Vector { _handler: CCU41_1 },
    Vector { _handler: CCU41_2 },
    Vector { _handler: CCU41_3 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: CCU80_0 },
    Vector { _handler: CCU80_1 },
    Vector { _handler: CCU80_2 },
    Vector { _handler: CCU80_3 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: CAN0_0 },
    Vector { _handler: CAN0_1 },
    Vector { _handler: CAN0_2 },
    Vector { _handler: CAN0_3 },
    Vector { _handler: CAN0_4 },
    Vector { _handler: CAN0_5 },
    Vector { _handler: CAN0_6 },
    Vector { _handler: CAN0_7 },
    Vector { _handler: USIC0_0 },
    Vector { _handler: USIC0_1 },
    Vector { _handler: USIC0_2 },
    Vector { _handler: USIC0_3 },
    Vector { _handler: USIC0_4 },
    Vector { _handler: USIC0_5 },
    Vector { _handler: USIC1_0 },
    Vector { _handler: USIC1_1 },
    Vector { _handler: USIC1_2 },
    Vector { _handler: USIC1_3 },
    Vector { _handler: USIC1_4 },
    Vector { _handler: USIC1_5 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: LEDTS0_0 },
    Vector { _reserved: 0 },
    Vector { _handler: FCE0_0 },
    Vector { _handler: GPDMA0_0 },
    Vector { _handler: SDMMC0_0 },
    Vector { _handler: USB0_0 },
    Vector { _handler: ETH0_0 },
    Vector { _handler: ECAT0_0 },
];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "0 - System Control"]
    SCU_0 = 0,
    #[doc = "1 - External Request Unit 0"]
    ERU0_0 = 1,
    #[doc = "2 - External Request Unit 0"]
    ERU0_1 = 2,
    #[doc = "3 - External Request Unit 0"]
    ERU0_2 = 3,
    #[doc = "4 - External Request Unit 0"]
    ERU0_3 = 4,
    #[doc = "5 - External Request Unit 1"]
    ERU1_0 = 5,
    #[doc = "6 - External Request Unit 1"]
    ERU1_1 = 6,
    #[doc = "7 - External Request Unit 1"]
    ERU1_2 = 7,
    #[doc = "8 - External Request Unit 1"]
    ERU1_3 = 8,
    #[doc = "12 - Program Management Unit"]
    PMU0_0 = 12,
    #[doc = "14 - Analog to Digital Converter Common Block 0"]
    VADC0_C0_0 = 14,
    #[doc = "15 - Analog to Digital Converter Common Block 0"]
    VADC0_C0_1 = 15,
    #[doc = "16 - Analog to Digital Converter Common Block 0"]
    VADC0_C0_2 = 16,
    #[doc = "17 - Analog to Digital Converter Common Block 0"]
    VADC0_C0_3 = 17,
    #[doc = "18 - Analog to Digital Converter Group 0"]
    VADC0_G0_0 = 18,
    #[doc = "19 - Analog to Digital Converter Group 0"]
    VADC0_G0_1 = 19,
    #[doc = "20 - Analog to Digital Converter Group 0"]
    VADC0_G0_2 = 20,
    #[doc = "21 - Analog to Digital Converter Group 0"]
    VADC0_G0_3 = 21,
    #[doc = "22 - Analog to Digital Converter Group 1"]
    VADC0_G1_0 = 22,
    #[doc = "23 - Analog to Digital Converter Group 1"]
    VADC0_G1_1 = 23,
    #[doc = "24 - Analog to Digital Converter Group 1"]
    VADC0_G1_2 = 24,
    #[doc = "25 - Analog to Digital Converter Group 1"]
    VADC0_G1_3 = 25,
    #[doc = "42 - Digital to Analog Converter"]
    DAC0_0 = 42,
    #[doc = "43 - Digital to Analog Converter"]
    DAC0_1 = 43,
    #[doc = "44 - Capture Compare Unit 4 (Module 0)"]
    CCU40_0 = 44,
    #[doc = "45 - Capture Compare Unit 4 (Module 0)"]
    CCU40_1 = 45,
    #[doc = "46 - Capture Compare Unit 4 (Module 0)"]
    CCU40_2 = 46,
    #[doc = "47 - Capture Compare Unit 4 (Module 0)"]
    CCU40_3 = 47,
    #[doc = "48 - Capture Compare Unit 4 (Module 1)"]
    CCU41_0 = 48,
    #[doc = "49 - Capture Compare Unit 4 (Module 1)"]
    CCU41_1 = 49,
    #[doc = "50 - Capture Compare Unit 4 (Module 1)"]
    CCU41_2 = 50,
    #[doc = "51 - Capture Compare Unit 4 (Module 1)"]
    CCU41_3 = 51,
    #[doc = "60 - Capture Compare Unit 8 (Module 0)"]
    CCU80_0 = 60,
    #[doc = "61 - Capture Compare Unit 8 (Module 0)"]
    CCU80_1 = 61,
    #[doc = "62 - Capture Compare Unit 8 (Module 0)"]
    CCU80_2 = 62,
    #[doc = "63 - Capture Compare Unit 8 (Module 0)"]
    CCU80_3 = 63,
    #[doc = "76 - MultiCAN"]
    CAN0_0 = 76,
    #[doc = "77 - MultiCAN"]
    CAN0_1 = 77,
    #[doc = "78 - MultiCAN"]
    CAN0_2 = 78,
    #[doc = "79 - MultiCAN"]
    CAN0_3 = 79,
    #[doc = "80 - MultiCAN"]
    CAN0_4 = 80,
    #[doc = "81 - MultiCAN"]
    CAN0_5 = 81,
    #[doc = "82 - MultiCAN"]
    CAN0_6 = 82,
    #[doc = "83 - MultiCAN"]
    CAN0_7 = 83,
    #[doc = "84 - Universal Serial Interface Channel (Module 0)"]
    USIC0_0 = 84,
    #[doc = "85 - Universal Serial Interface Channel (Module 0)"]
    USIC0_1 = 85,
    #[doc = "86 - Universal Serial Interface Channel (Module 0)"]
    USIC0_2 = 86,
    #[doc = "87 - Universal Serial Interface Channel (Module 0)"]
    USIC0_3 = 87,
    #[doc = "88 - Universal Serial Interface Channel (Module 0)"]
    USIC0_4 = 88,
    #[doc = "89 - Universal Serial Interface Channel (Module 0)"]
    USIC0_5 = 89,
    #[doc = "90 - Universal Serial Interface Channel (Module 1)"]
    USIC1_0 = 90,
    #[doc = "91 - Universal Serial Interface Channel (Module 1)"]
    USIC1_1 = 91,
    #[doc = "92 - Universal Serial Interface Channel (Module 1)"]
    USIC1_2 = 92,
    #[doc = "93 - Universal Serial Interface Channel (Module 1)"]
    USIC1_3 = 93,
    #[doc = "94 - Universal Serial Interface Channel (Module 1)"]
    USIC1_4 = 94,
    #[doc = "95 - Universal Serial Interface Channel (Module 1)"]
    USIC1_5 = 95,
    #[doc = "102 - LED and Touch Sense Control Unit (Module 0)"]
    LEDTS0_0 = 102,
    #[doc = "104 - Flexible CRC Engine"]
    FCE0_0 = 104,
    #[doc = "105 - General Purpose DMA Unit 0"]
    GPDMA0_0 = 105,
    #[doc = "106 - Multi Media Card Interface"]
    SDMMC0_0 = 106,
    #[doc = "107 - Universal Serial Bus (Module 0)"]
    USB0_0 = 107,
    #[doc = "108 - Ethernet (Module 0)"]
    ETH0_0 = 108,
    #[doc = "109 - EtherCAT (Module 0)"]
    ECAT0_0 = 109,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "Cortex-M4 Private Peripheral Block"]
pub struct Ppb {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ppb {}
impl Ppb {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ppb::RegisterBlock = 0xe000_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ppb::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ppb {
    type Target = ppb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ppb {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ppb").finish()
    }
}
#[doc = "Cortex-M4 Private Peripheral Block"]
pub mod ppb;
#[doc = "DMA Line Router"]
pub struct Dlr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dlr {}
impl Dlr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dlr::RegisterBlock = 0x5000_4900 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dlr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Dlr {
    type Target = dlr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dlr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dlr").finish()
    }
}
#[doc = "DMA Line Router"]
pub mod dlr;
#[doc = "Event Request Unit 0"]
pub struct Eru0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Eru0 {}
impl Eru0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eru0::RegisterBlock = 0x5000_4800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eru0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Eru0 {
    type Target = eru0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Eru0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Eru0").finish()
    }
}
#[doc = "Event Request Unit 0"]
pub mod eru0;
#[doc = "Event Request Unit 1"]
pub struct Eru1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Eru1 {}
impl Eru1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eru0::RegisterBlock = 0x4004_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eru0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Eru1 {
    type Target = eru0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Eru1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Eru1").finish()
    }
}
#[doc = "Event Request Unit 1"]
pub use self::eru0 as eru1;
#[doc = "General Purpose DMA Unit 0"]
pub struct Gpdma0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma0 {}
impl Gpdma0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma0::RegisterBlock = 0x5001_42c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma0 {
    type Target = gpdma0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma0").finish()
    }
}
#[doc = "General Purpose DMA Unit 0"]
pub mod gpdma0;
#[doc = "General Purpose DMA Unit 0"]
pub struct Gpdma0Ch0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma0Ch0 {}
impl Gpdma0Ch0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma0_ch0::RegisterBlock = 0x5001_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma0Ch0 {
    type Target = gpdma0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma0Ch0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma0Ch0").finish()
    }
}
#[doc = "General Purpose DMA Unit 0"]
pub mod gpdma0_ch0;
#[doc = "General Purpose DMA Unit 0"]
pub struct Gpdma0Ch1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma0Ch1 {}
impl Gpdma0Ch1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma0_ch0::RegisterBlock = 0x5001_4058 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma0Ch1 {
    type Target = gpdma0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma0Ch1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma0Ch1").finish()
    }
}
#[doc = "General Purpose DMA Unit 0"]
pub use self::gpdma0_ch0 as gpdma0_ch1;
#[doc = "General Purpose DMA Unit 0"]
pub struct Gpdma0Ch2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma0Ch2 {}
impl Gpdma0Ch2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma0_ch2::RegisterBlock = 0x5001_40b0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma0_ch2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma0Ch2 {
    type Target = gpdma0_ch2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma0Ch2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma0Ch2").finish()
    }
}
#[doc = "General Purpose DMA Unit 0"]
pub mod gpdma0_ch2;
#[doc = "General Purpose DMA Unit 0"]
pub struct Gpdma0Ch3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma0Ch3 {}
impl Gpdma0Ch3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma0_ch2::RegisterBlock = 0x5001_4108 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma0_ch2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma0Ch3 {
    type Target = gpdma0_ch2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma0Ch3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma0Ch3").finish()
    }
}
#[doc = "General Purpose DMA Unit 0"]
pub use self::gpdma0_ch2 as gpdma0_ch3;
#[doc = "General Purpose DMA Unit 0"]
pub struct Gpdma0Ch4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma0Ch4 {}
impl Gpdma0Ch4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma0_ch2::RegisterBlock = 0x5001_4160 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma0_ch2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma0Ch4 {
    type Target = gpdma0_ch2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma0Ch4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma0Ch4").finish()
    }
}
#[doc = "General Purpose DMA Unit 0"]
pub use self::gpdma0_ch2 as gpdma0_ch4;
#[doc = "General Purpose DMA Unit 0"]
pub struct Gpdma0Ch5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma0Ch5 {}
impl Gpdma0Ch5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma0_ch2::RegisterBlock = 0x5001_41b8 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma0_ch2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma0Ch5 {
    type Target = gpdma0_ch2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma0Ch5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma0Ch5").finish()
    }
}
#[doc = "General Purpose DMA Unit 0"]
pub use self::gpdma0_ch2 as gpdma0_ch5;
#[doc = "General Purpose DMA Unit 0"]
pub struct Gpdma0Ch6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma0Ch6 {}
impl Gpdma0Ch6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma0_ch2::RegisterBlock = 0x5001_4210 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma0_ch2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma0Ch6 {
    type Target = gpdma0_ch2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma0Ch6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma0Ch6").finish()
    }
}
#[doc = "General Purpose DMA Unit 0"]
pub use self::gpdma0_ch2 as gpdma0_ch6;
#[doc = "General Purpose DMA Unit 0"]
pub struct Gpdma0Ch7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpdma0Ch7 {}
impl Gpdma0Ch7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpdma0_ch2::RegisterBlock = 0x5001_4268 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpdma0_ch2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Gpdma0Ch7 {
    type Target = gpdma0_ch2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpdma0Ch7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpdma0Ch7").finish()
    }
}
#[doc = "General Purpose DMA Unit 0"]
pub use self::gpdma0_ch2 as gpdma0_ch7;
#[doc = "Flexible CRC Engine"]
pub struct Fce {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fce {}
impl Fce {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fce::RegisterBlock = 0x5002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fce::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Fce {
    type Target = fce::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fce {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fce").finish()
    }
}
#[doc = "Flexible CRC Engine"]
pub mod fce;
#[doc = "Flexible CRC Engine"]
pub struct FceKe0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FceKe0 {}
impl FceKe0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fce_ke0::RegisterBlock = 0x5002_0020 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fce_ke0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for FceKe0 {
    type Target = fce_ke0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FceKe0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FceKe0").finish()
    }
}
#[doc = "Flexible CRC Engine"]
pub mod fce_ke0;
#[doc = "Flexible CRC Engine"]
pub struct FceKe1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FceKe1 {}
impl FceKe1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fce_ke0::RegisterBlock = 0x5002_0040 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fce_ke0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for FceKe1 {
    type Target = fce_ke0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FceKe1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FceKe1").finish()
    }
}
#[doc = "Flexible CRC Engine"]
pub use self::fce_ke0 as fce_ke1;
#[doc = "Flexible CRC Engine"]
pub struct FceKe2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FceKe2 {}
impl FceKe2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fce_ke0::RegisterBlock = 0x5002_0060 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fce_ke0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for FceKe2 {
    type Target = fce_ke0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FceKe2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FceKe2").finish()
    }
}
#[doc = "Flexible CRC Engine"]
pub use self::fce_ke0 as fce_ke2;
#[doc = "Flexible CRC Engine"]
pub struct FceKe3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FceKe3 {}
impl FceKe3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fce_ke0::RegisterBlock = 0x5002_0080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fce_ke0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for FceKe3 {
    type Target = fce_ke0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FceKe3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FceKe3").finish()
    }
}
#[doc = "Flexible CRC Engine"]
pub use self::fce_ke0 as fce_ke3;
#[doc = "Peripheral Bridge AHB 0"]
pub struct Pba0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pba0 {}
impl Pba0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pba0::RegisterBlock = 0x4000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pba0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Pba0 {
    type Target = pba0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pba0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pba0").finish()
    }
}
#[doc = "Peripheral Bridge AHB 0"]
pub mod pba0;
#[doc = "Peripheral Bridge AHB 1"]
pub struct Pba1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pba1 {}
impl Pba1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pba0::RegisterBlock = 0x4800_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pba0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Pba1 {
    type Target = pba0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pba1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pba1").finish()
    }
}
#[doc = "Peripheral Bridge AHB 1"]
pub use self::pba0 as pba1;
#[doc = "Flash Memory Controller"]
pub struct Flash0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Flash0 {}
impl Flash0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const flash0::RegisterBlock = 0x5800_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const flash0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Flash0 {
    type Target = flash0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Flash0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Flash0").finish()
    }
}
#[doc = "Flash Memory Controller"]
pub mod flash0;
#[doc = "Prefetch Unit"]
pub struct Pref {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pref {}
impl Pref {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pref::RegisterBlock = 0x5800_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pref::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Pref {
    type Target = pref::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pref {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pref").finish()
    }
}
#[doc = "Prefetch Unit"]
pub mod pref;
#[doc = "Program Management Unit"]
pub struct Pmu0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pmu0 {}
impl Pmu0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pmu0::RegisterBlock = 0x5800_0508 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pmu0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Pmu0 {
    type Target = pmu0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pmu0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pmu0").finish()
    }
}
#[doc = "Program Management Unit"]
pub mod pmu0;
#[doc = "Watch Dog Timer"]
pub struct Wdt {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Wdt {}
impl Wdt {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdt::RegisterBlock = 0x5000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Wdt {
    type Target = wdt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Wdt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Wdt").finish()
    }
}
#[doc = "Watch Dog Timer"]
pub mod wdt;
#[doc = "Real Time Clock"]
pub struct Rtc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rtc {}
impl Rtc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rtc::RegisterBlock = 0x5000_4a00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rtc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Rtc {
    type Target = rtc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rtc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rtc").finish()
    }
}
#[doc = "Real Time Clock"]
pub mod rtc;
#[doc = "System Control Unit"]
pub struct ScuClk {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScuClk {}
impl ScuClk {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scu_clk::RegisterBlock = 0x5000_4600 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scu_clk::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for ScuClk {
    type Target = scu_clk::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScuClk {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScuClk").finish()
    }
}
#[doc = "System Control Unit"]
pub mod scu_clk;
#[doc = "System Control Unit"]
pub struct ScuOsc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScuOsc {}
impl ScuOsc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scu_osc::RegisterBlock = 0x5000_4700 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scu_osc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for ScuOsc {
    type Target = scu_osc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScuOsc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScuOsc").finish()
    }
}
#[doc = "System Control Unit"]
pub mod scu_osc;
#[doc = "System Control Unit"]
pub struct ScuPll {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScuPll {}
impl ScuPll {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scu_pll::RegisterBlock = 0x5000_4710 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scu_pll::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for ScuPll {
    type Target = scu_pll::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScuPll {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScuPll").finish()
    }
}
#[doc = "System Control Unit"]
pub mod scu_pll;
#[doc = "System Control Unit"]
pub struct ScuGeneral {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScuGeneral {}
impl ScuGeneral {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scu_general::RegisterBlock = 0x5000_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scu_general::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for ScuGeneral {
    type Target = scu_general::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScuGeneral {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScuGeneral").finish()
    }
}
#[doc = "System Control Unit"]
pub mod scu_general;
#[doc = "System Control Unit"]
pub struct ScuInterrupt {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScuInterrupt {}
impl ScuInterrupt {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scu_interrupt::RegisterBlock = 0x5000_4074 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scu_interrupt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for ScuInterrupt {
    type Target = scu_interrupt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScuInterrupt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScuInterrupt").finish()
    }
}
#[doc = "System Control Unit"]
pub mod scu_interrupt;
#[doc = "System Control Unit"]
pub struct ScuParity {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScuParity {}
impl ScuParity {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scu_parity::RegisterBlock = 0x5000_413c as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scu_parity::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for ScuParity {
    type Target = scu_parity::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScuParity {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScuParity").finish()
    }
}
#[doc = "System Control Unit"]
pub mod scu_parity;
#[doc = "System Control Unit"]
pub struct ScuTrap {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScuTrap {}
impl ScuTrap {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scu_trap::RegisterBlock = 0x5000_4160 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scu_trap::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for ScuTrap {
    type Target = scu_trap::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScuTrap {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScuTrap").finish()
    }
}
#[doc = "System Control Unit"]
pub mod scu_trap;
#[doc = "System Control Unit"]
pub struct ScuHibernate {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScuHibernate {}
impl ScuHibernate {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scu_hibernate::RegisterBlock = 0x5000_4300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scu_hibernate::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for ScuHibernate {
    type Target = scu_hibernate::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScuHibernate {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScuHibernate").finish()
    }
}
#[doc = "System Control Unit"]
pub mod scu_hibernate;
#[doc = "System Control Unit"]
pub struct ScuPower {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScuPower {}
impl ScuPower {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scu_power::RegisterBlock = 0x5000_4200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scu_power::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for ScuPower {
    type Target = scu_power::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScuPower {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScuPower").finish()
    }
}
#[doc = "System Control Unit"]
pub mod scu_power;
#[doc = "System Control Unit"]
pub struct ScuReset {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScuReset {}
impl ScuReset {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scu_reset::RegisterBlock = 0x5000_4400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scu_reset::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for ScuReset {
    type Target = scu_reset::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScuReset {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScuReset").finish()
    }
}
#[doc = "System Control Unit"]
pub mod scu_reset;
#[doc = "LED and Touch Sense Unit 0"]
pub struct Ledts0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ledts0 {}
impl Ledts0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ledts0::RegisterBlock = 0x4801_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ledts0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ledts0 {
    type Target = ledts0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ledts0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ledts0").finish()
    }
}
#[doc = "LED and Touch Sense Unit 0"]
pub mod ledts0;
#[doc = "SD and Multimediacard Control Register"]
pub struct SdmmcCon {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SdmmcCon {}
impl SdmmcCon {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sdmmc_con::RegisterBlock = 0x5000_40b4 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sdmmc_con::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for SdmmcCon {
    type Target = sdmmc_con::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SdmmcCon {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SdmmcCon").finish()
    }
}
#[doc = "SD and Multimediacard Control Register"]
pub mod sdmmc_con;
#[doc = "SD and Multimediacard Interface"]
pub struct Sdmmc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Sdmmc {}
impl Sdmmc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sdmmc::RegisterBlock = 0x4801_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sdmmc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Sdmmc {
    type Target = sdmmc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Sdmmc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sdmmc").finish()
    }
}
#[doc = "SD and Multimediacard Interface"]
pub mod sdmmc;
#[doc = "Ethernet Control Register"]
pub struct Eth0Con {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Eth0Con {}
impl Eth0Con {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eth0_con::RegisterBlock = 0x5000_4040 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eth0_con::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Eth0Con {
    type Target = eth0_con::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Eth0Con {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Eth0Con").finish()
    }
}
#[doc = "Ethernet Control Register"]
pub mod eth0_con;
#[doc = "Ethernet Unit 0"]
pub struct Eth0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Eth0 {}
impl Eth0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eth0::RegisterBlock = 0x5000_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eth0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Eth0 {
    type Target = eth0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Eth0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Eth0").finish()
    }
}
#[doc = "Ethernet Unit 0"]
pub mod eth0;
#[doc = "EtherCAT 0 Control Register"]
pub struct Ecat0Con {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecat0Con {}
impl Ecat0Con {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecat0_con::RegisterBlock = 0x5000_41b0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecat0_con::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ecat0Con {
    type Target = ecat0_con::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecat0Con {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecat0Con").finish()
    }
}
#[doc = "EtherCAT 0 Control Register"]
pub mod ecat0_con;
#[doc = "EtherCAT 0"]
pub struct Ecat0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecat0 {}
impl Ecat0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecat0::RegisterBlock = 0x5401_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecat0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ecat0 {
    type Target = ecat0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecat0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecat0").finish()
    }
}
#[doc = "EtherCAT 0"]
pub mod ecat0;
#[doc = "EtherCAT 0"]
pub struct Ecat0Fmmu0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecat0Fmmu0 {}
impl Ecat0Fmmu0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecat0_fmmu0::RegisterBlock = 0x5401_0600 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecat0_fmmu0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ecat0Fmmu0 {
    type Target = ecat0_fmmu0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecat0Fmmu0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecat0Fmmu0").finish()
    }
}
#[doc = "EtherCAT 0"]
pub mod ecat0_fmmu0;
#[doc = "EtherCAT 0"]
pub struct Ecat0Fmmu1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecat0Fmmu1 {}
impl Ecat0Fmmu1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecat0_fmmu0::RegisterBlock = 0x5401_0610 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecat0_fmmu0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ecat0Fmmu1 {
    type Target = ecat0_fmmu0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecat0Fmmu1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecat0Fmmu1").finish()
    }
}
#[doc = "EtherCAT 0"]
pub use self::ecat0_fmmu0 as ecat0_fmmu1;
#[doc = "EtherCAT 0"]
pub struct Ecat0Fmmu2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecat0Fmmu2 {}
impl Ecat0Fmmu2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecat0_fmmu0::RegisterBlock = 0x5401_0620 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecat0_fmmu0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ecat0Fmmu2 {
    type Target = ecat0_fmmu0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecat0Fmmu2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecat0Fmmu2").finish()
    }
}
#[doc = "EtherCAT 0"]
pub use self::ecat0_fmmu0 as ecat0_fmmu2;
#[doc = "EtherCAT 0"]
pub struct Ecat0Fmmu3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecat0Fmmu3 {}
impl Ecat0Fmmu3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecat0_fmmu0::RegisterBlock = 0x5401_0630 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecat0_fmmu0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ecat0Fmmu3 {
    type Target = ecat0_fmmu0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecat0Fmmu3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecat0Fmmu3").finish()
    }
}
#[doc = "EtherCAT 0"]
pub use self::ecat0_fmmu0 as ecat0_fmmu3;
#[doc = "EtherCAT 0"]
pub struct Ecat0Fmmu4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecat0Fmmu4 {}
impl Ecat0Fmmu4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecat0_fmmu0::RegisterBlock = 0x5401_0640 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecat0_fmmu0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ecat0Fmmu4 {
    type Target = ecat0_fmmu0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecat0Fmmu4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecat0Fmmu4").finish()
    }
}
#[doc = "EtherCAT 0"]
pub use self::ecat0_fmmu0 as ecat0_fmmu4;
#[doc = "EtherCAT 0"]
pub struct Ecat0Fmmu5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecat0Fmmu5 {}
impl Ecat0Fmmu5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecat0_fmmu0::RegisterBlock = 0x5401_0650 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecat0_fmmu0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ecat0Fmmu5 {
    type Target = ecat0_fmmu0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecat0Fmmu5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecat0Fmmu5").finish()
    }
}
#[doc = "EtherCAT 0"]
pub use self::ecat0_fmmu0 as ecat0_fmmu5;
#[doc = "EtherCAT 0"]
pub struct Ecat0Fmmu6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecat0Fmmu6 {}
impl Ecat0Fmmu6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecat0_fmmu0::RegisterBlock = 0x5401_0660 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecat0_fmmu0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ecat0Fmmu6 {
    type Target = ecat0_fmmu0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecat0Fmmu6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecat0Fmmu6").finish()
    }
}
#[doc = "EtherCAT 0"]
pub use self::ecat0_fmmu0 as ecat0_fmmu6;
#[doc = "EtherCAT 0"]
pub struct Ecat0Fmmu7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecat0Fmmu7 {}
impl Ecat0Fmmu7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecat0_fmmu0::RegisterBlock = 0x5401_0670 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecat0_fmmu0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ecat0Fmmu7 {
    type Target = ecat0_fmmu0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecat0Fmmu7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecat0Fmmu7").finish()
    }
}
#[doc = "EtherCAT 0"]
pub use self::ecat0_fmmu0 as ecat0_fmmu7;
#[doc = "EtherCAT 0"]
pub struct Ecat0Sm0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecat0Sm0 {}
impl Ecat0Sm0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecat0_sm0::RegisterBlock = 0x5401_0800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecat0_sm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ecat0Sm0 {
    type Target = ecat0_sm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecat0Sm0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecat0Sm0").finish()
    }
}
#[doc = "EtherCAT 0"]
pub mod ecat0_sm0;
#[doc = "EtherCAT 0"]
pub struct Ecat0Sm1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecat0Sm1 {}
impl Ecat0Sm1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecat0_sm0::RegisterBlock = 0x5401_0808 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecat0_sm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ecat0Sm1 {
    type Target = ecat0_sm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecat0Sm1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecat0Sm1").finish()
    }
}
#[doc = "EtherCAT 0"]
pub use self::ecat0_sm0 as ecat0_sm1;
#[doc = "EtherCAT 0"]
pub struct Ecat0Sm2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecat0Sm2 {}
impl Ecat0Sm2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecat0_sm0::RegisterBlock = 0x5401_0810 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecat0_sm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ecat0Sm2 {
    type Target = ecat0_sm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecat0Sm2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecat0Sm2").finish()
    }
}
#[doc = "EtherCAT 0"]
pub use self::ecat0_sm0 as ecat0_sm2;
#[doc = "EtherCAT 0"]
pub struct Ecat0Sm3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecat0Sm3 {}
impl Ecat0Sm3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecat0_sm0::RegisterBlock = 0x5401_0818 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecat0_sm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ecat0Sm3 {
    type Target = ecat0_sm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecat0Sm3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecat0Sm3").finish()
    }
}
#[doc = "EtherCAT 0"]
pub use self::ecat0_sm0 as ecat0_sm3;
#[doc = "EtherCAT 0"]
pub struct Ecat0Sm4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecat0Sm4 {}
impl Ecat0Sm4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecat0_sm0::RegisterBlock = 0x5401_0820 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecat0_sm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ecat0Sm4 {
    type Target = ecat0_sm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecat0Sm4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecat0Sm4").finish()
    }
}
#[doc = "EtherCAT 0"]
pub use self::ecat0_sm0 as ecat0_sm4;
#[doc = "EtherCAT 0"]
pub struct Ecat0Sm5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecat0Sm5 {}
impl Ecat0Sm5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecat0_sm0::RegisterBlock = 0x5401_0828 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecat0_sm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ecat0Sm5 {
    type Target = ecat0_sm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecat0Sm5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecat0Sm5").finish()
    }
}
#[doc = "EtherCAT 0"]
pub use self::ecat0_sm0 as ecat0_sm5;
#[doc = "EtherCAT 0"]
pub struct Ecat0Sm6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecat0Sm6 {}
impl Ecat0Sm6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecat0_sm0::RegisterBlock = 0x5401_0830 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecat0_sm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ecat0Sm6 {
    type Target = ecat0_sm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecat0Sm6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecat0Sm6").finish()
    }
}
#[doc = "EtherCAT 0"]
pub use self::ecat0_sm0 as ecat0_sm6;
#[doc = "EtherCAT 0"]
pub struct Ecat0Sm7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecat0Sm7 {}
impl Ecat0Sm7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecat0_sm0::RegisterBlock = 0x5401_0838 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecat0_sm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ecat0Sm7 {
    type Target = ecat0_sm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecat0Sm7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecat0Sm7").finish()
    }
}
#[doc = "EtherCAT 0"]
pub use self::ecat0_sm0 as ecat0_sm7;
#[doc = "Universal Serial Bus"]
pub struct Usb0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0 {}
impl Usb0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0::RegisterBlock = 0x5004_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0 {
    type Target = usb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub mod usb0;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ep0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ep0 {}
impl Usb0Ep0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ep0::RegisterBlock = 0x5004_0900 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ep0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ep0 {
    type Target = usb0_ep0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ep0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ep0").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub mod usb0_ep0;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ep1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ep1 {}
impl Usb0Ep1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ep1::RegisterBlock = 0x5004_0920 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ep1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ep1 {
    type Target = usb0_ep1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ep1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ep1").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub mod usb0_ep1;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ep2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ep2 {}
impl Usb0Ep2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ep1::RegisterBlock = 0x5004_0940 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ep1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ep2 {
    type Target = usb0_ep1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ep2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ep2").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ep1 as usb0_ep2;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ep3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ep3 {}
impl Usb0Ep3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ep1::RegisterBlock = 0x5004_0960 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ep1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ep3 {
    type Target = usb0_ep1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ep3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ep3").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ep1 as usb0_ep3;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ep4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ep4 {}
impl Usb0Ep4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ep1::RegisterBlock = 0x5004_0980 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ep1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ep4 {
    type Target = usb0_ep1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ep4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ep4").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ep1 as usb0_ep4;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ep5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ep5 {}
impl Usb0Ep5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ep1::RegisterBlock = 0x5004_09a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ep1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ep5 {
    type Target = usb0_ep1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ep5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ep5").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ep1 as usb0_ep5;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ep6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ep6 {}
impl Usb0Ep6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ep1::RegisterBlock = 0x5004_09c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ep1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ep6 {
    type Target = usb0_ep1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ep6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ep6").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ep1 as usb0_ep6;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch0 {}
impl Usb0Ch0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_0500 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch0 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch0").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub mod usb0_ch0;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch1 {}
impl Usb0Ch1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_0520 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch1 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch1").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch1;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch2 {}
impl Usb0Ch2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_0540 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch2 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch2").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch2;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch3 {}
impl Usb0Ch3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_0560 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch3 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch3").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch3;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch4 {}
impl Usb0Ch4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_0580 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch4 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch4").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch4;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch5 {}
impl Usb0Ch5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_05a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch5 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch5").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch5;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch6 {}
impl Usb0Ch6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_05c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch6 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch6").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch6;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch7 {}
impl Usb0Ch7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_05e0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch7 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch7").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch7;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch8 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch8 {}
impl Usb0Ch8 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_0600 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch8 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch8").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch8;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch9 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch9 {}
impl Usb0Ch9 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_0620 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch9 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch9").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch9;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch10 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch10 {}
impl Usb0Ch10 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_0640 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch10 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch10").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch10;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch11 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch11 {}
impl Usb0Ch11 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_0660 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch11 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch11").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch11;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch12 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch12 {}
impl Usb0Ch12 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_0680 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch12 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch12").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch12;
#[doc = "Universal Serial Bus"]
pub struct Usb0Ch13 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb0Ch13 {}
impl Usb0Ch13 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0_ch0::RegisterBlock = 0x5004_06a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usb0Ch13 {
    type Target = usb0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb0Ch13 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb0Ch13").finish()
    }
}
#[doc = "Universal Serial Bus"]
pub use self::usb0_ch0 as usb0_ch13;
#[doc = "Universal Serial Interface Controller 0"]
pub struct Usic0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usic0 {}
impl Usic0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usic0::RegisterBlock = 0x4003_0008 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usic0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usic0 {
    type Target = usic0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usic0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usic0").finish()
    }
}
#[doc = "Universal Serial Interface Controller 0"]
pub mod usic0;
#[doc = "Universal Serial Interface Controller 1"]
pub struct Usic1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usic1 {}
impl Usic1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usic0::RegisterBlock = 0x4802_0008 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usic0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usic1 {
    type Target = usic0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usic1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usic1").finish()
    }
}
#[doc = "Universal Serial Interface Controller 1"]
pub use self::usic0 as usic1;
#[doc = "Universal Serial Interface Controller 0"]
pub struct Usic0Ch0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usic0Ch0 {}
impl Usic0Ch0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usic0_ch0::RegisterBlock = 0x4003_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usic0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usic0Ch0 {
    type Target = usic0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usic0Ch0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usic0Ch0").finish()
    }
}
#[doc = "Universal Serial Interface Controller 0"]
pub mod usic0_ch0;
#[doc = "Universal Serial Interface Controller 0"]
pub struct Usic0Ch1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usic0Ch1 {}
impl Usic0Ch1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usic0_ch0::RegisterBlock = 0x4003_0200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usic0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usic0Ch1 {
    type Target = usic0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usic0Ch1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usic0Ch1").finish()
    }
}
#[doc = "Universal Serial Interface Controller 0"]
pub use self::usic0_ch0 as usic0_ch1;
#[doc = "Universal Serial Interface Controller 0"]
pub struct Usic1Ch0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usic1Ch0 {}
impl Usic1Ch0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usic0_ch0::RegisterBlock = 0x4802_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usic0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usic1Ch0 {
    type Target = usic0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usic1Ch0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usic1Ch0").finish()
    }
}
#[doc = "Universal Serial Interface Controller 0"]
pub use self::usic0_ch0 as usic1_ch0;
#[doc = "Universal Serial Interface Controller 0"]
pub struct Usic1Ch1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usic1Ch1 {}
impl Usic1Ch1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usic0_ch0::RegisterBlock = 0x4802_0200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usic0_ch0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Usic1Ch1 {
    type Target = usic0_ch0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usic1Ch1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usic1Ch1").finish()
    }
}
#[doc = "Universal Serial Interface Controller 0"]
pub use self::usic0_ch0 as usic1_ch1;
#[doc = "Controller Area Networks"]
pub struct Can {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Can {}
impl Can {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can::RegisterBlock = 0x4801_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Can {
    type Target = can::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Can {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Can").finish()
    }
}
#[doc = "Controller Area Networks"]
pub mod can;
#[doc = "Controller Area Networks"]
pub struct CanNode0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanNode0 {}
impl CanNode0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_node0::RegisterBlock = 0x4801_4200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_node0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanNode0 {
    type Target = can_node0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanNode0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanNode0").finish()
    }
}
#[doc = "Controller Area Networks"]
pub mod can_node0;
#[doc = "Controller Area Networks"]
pub struct CanNode1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanNode1 {}
impl CanNode1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_node0::RegisterBlock = 0x4801_4300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_node0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanNode1 {
    type Target = can_node0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanNode1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanNode1").finish()
    }
}
#[doc = "Controller Area Networks"]
pub use self::can_node0 as can_node1;
#[doc = "Controller Area Networks"]
pub struct CanMo {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CanMo {}
impl CanMo {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const can_mo::RegisterBlock = 0x4801_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const can_mo::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for CanMo {
    type Target = can_mo::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CanMo {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CanMo").finish()
    }
}
#[doc = "Controller Area Networks"]
pub mod can_mo;
#[doc = "Analog to Digital Converter"]
pub struct Vadc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Vadc {}
impl Vadc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vadc::RegisterBlock = 0x4000_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vadc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Vadc {
    type Target = vadc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Vadc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vadc").finish()
    }
}
#[doc = "Analog to Digital Converter"]
pub mod vadc;
#[doc = "Analog to Digital Converter"]
pub struct VadcG0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for VadcG0 {}
impl VadcG0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vadc_g0::RegisterBlock = 0x4000_4400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vadc_g0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for VadcG0 {
    type Target = vadc_g0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for VadcG0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("VadcG0").finish()
    }
}
#[doc = "Analog to Digital Converter"]
pub mod vadc_g0;
#[doc = "Analog to Digital Converter"]
pub struct VadcG1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for VadcG1 {}
impl VadcG1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vadc_g0::RegisterBlock = 0x4000_4800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vadc_g0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for VadcG1 {
    type Target = vadc_g0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for VadcG1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("VadcG1").finish()
    }
}
#[doc = "Analog to Digital Converter"]
pub use self::vadc_g0 as vadc_g1;
#[doc = "Digital to Analog Converter"]
pub struct Dac {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dac {}
impl Dac {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dac::RegisterBlock = 0x4801_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dac::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Dac {
    type Target = dac::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dac {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dac").finish()
    }
}
#[doc = "Digital to Analog Converter"]
pub mod dac;
#[doc = "Capture Compare Unit 4 - Unit 0"]
pub struct Ccu40 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu40 {}
impl Ccu40 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40::RegisterBlock = 0x4000_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu40 {
    type Target = ccu40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu40 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu40").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 0"]
pub mod ccu40;
#[doc = "Capture Compare Unit 4 - Unit 1"]
pub struct Ccu41 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu41 {}
impl Ccu41 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40::RegisterBlock = 0x4001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu41 {
    type Target = ccu40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu41 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu41").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 1"]
pub use self::ccu40 as ccu41;
#[doc = "Capture Compare Unit 4 - Unit 0"]
pub struct Ccu40Cc40 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu40Cc40 {}
impl Ccu40Cc40 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4000_c100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu40Cc40 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu40Cc40 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu40Cc40").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 0"]
pub mod ccu40_cc40;
#[doc = "Capture Compare Unit 4 - Unit 0"]
pub struct Ccu40Cc41 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu40Cc41 {}
impl Ccu40Cc41 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4000_c200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu40Cc41 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu40Cc41 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu40Cc41").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 0"]
pub use self::ccu40_cc40 as ccu40_cc41;
#[doc = "Capture Compare Unit 4 - Unit 0"]
pub struct Ccu40Cc42 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu40Cc42 {}
impl Ccu40Cc42 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4000_c300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu40Cc42 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu40Cc42 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu40Cc42").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 0"]
pub use self::ccu40_cc40 as ccu40_cc42;
#[doc = "Capture Compare Unit 4 - Unit 0"]
pub struct Ccu40Cc43 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu40Cc43 {}
impl Ccu40Cc43 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4000_c400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu40Cc43 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu40Cc43 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu40Cc43").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 0"]
pub use self::ccu40_cc40 as ccu40_cc43;
#[doc = "Capture Compare Unit 4 - Unit 1"]
pub struct Ccu41Cc40 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu41Cc40 {}
impl Ccu41Cc40 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4001_0100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu41Cc40 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu41Cc40 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu41Cc40").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 1"]
pub use self::ccu40_cc40 as ccu41_cc40;
#[doc = "Capture Compare Unit 4 - Unit 1"]
pub struct Ccu41Cc41 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu41Cc41 {}
impl Ccu41Cc41 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4001_0200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu41Cc41 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu41Cc41 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu41Cc41").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 1"]
pub use self::ccu40_cc40 as ccu41_cc41;
#[doc = "Capture Compare Unit 4 - Unit 1"]
pub struct Ccu41Cc42 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu41Cc42 {}
impl Ccu41Cc42 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4001_0300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu41Cc42 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu41Cc42 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu41Cc42").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 1"]
pub use self::ccu40_cc40 as ccu41_cc42;
#[doc = "Capture Compare Unit 4 - Unit 1"]
pub struct Ccu41Cc43 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu41Cc43 {}
impl Ccu41Cc43 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu40_cc40::RegisterBlock = 0x4001_0400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu40_cc40::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu41Cc43 {
    type Target = ccu40_cc40::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu41Cc43 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu41Cc43").finish()
    }
}
#[doc = "Capture Compare Unit 4 - Unit 1"]
pub use self::ccu40_cc40 as ccu41_cc43;
#[doc = "Capture Compare Unit 8 - Unit 0"]
pub struct Ccu80 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu80 {}
impl Ccu80 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu80::RegisterBlock = 0x4002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu80::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu80 {
    type Target = ccu80::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu80 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu80").finish()
    }
}
#[doc = "Capture Compare Unit 8 - Unit 0"]
pub mod ccu80;
#[doc = "Capture Compare Unit 8 - Unit 0"]
pub struct Ccu80Cc80 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu80Cc80 {}
impl Ccu80Cc80 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu80_cc80::RegisterBlock = 0x4002_0100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu80_cc80::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu80Cc80 {
    type Target = ccu80_cc80::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu80Cc80 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu80Cc80").finish()
    }
}
#[doc = "Capture Compare Unit 8 - Unit 0"]
pub mod ccu80_cc80;
#[doc = "Capture Compare Unit 8 - Unit 0"]
pub struct Ccu80Cc81 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu80Cc81 {}
impl Ccu80Cc81 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu80_cc80::RegisterBlock = 0x4002_0200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu80_cc80::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu80Cc81 {
    type Target = ccu80_cc80::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu80Cc81 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu80Cc81").finish()
    }
}
#[doc = "Capture Compare Unit 8 - Unit 0"]
pub use self::ccu80_cc80 as ccu80_cc81;
#[doc = "Capture Compare Unit 8 - Unit 0"]
pub struct Ccu80Cc82 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu80Cc82 {}
impl Ccu80Cc82 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu80_cc80::RegisterBlock = 0x4002_0300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu80_cc80::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu80Cc82 {
    type Target = ccu80_cc80::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu80Cc82 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu80Cc82").finish()
    }
}
#[doc = "Capture Compare Unit 8 - Unit 0"]
pub use self::ccu80_cc80 as ccu80_cc82;
#[doc = "Capture Compare Unit 8 - Unit 0"]
pub struct Ccu80Cc83 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ccu80Cc83 {}
impl Ccu80Cc83 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccu80_cc80::RegisterBlock = 0x4002_0400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccu80_cc80::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Ccu80Cc83 {
    type Target = ccu80_cc80::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ccu80Cc83 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu80Cc83").finish()
    }
}
#[doc = "Capture Compare Unit 8 - Unit 0"]
pub use self::ccu80_cc80 as ccu80_cc83;
#[doc = "Port 0"]
pub struct Port0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Port0 {}
impl Port0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const port0::RegisterBlock = 0x4802_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const port0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Port0 {
    type Target = port0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Port0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Port0").finish()
    }
}
#[doc = "Port 0"]
pub mod port0;
#[doc = "Port 1"]
pub struct Port1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Port1 {}
impl Port1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const port1::RegisterBlock = 0x4802_8100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const port1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Port1 {
    type Target = port1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Port1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Port1").finish()
    }
}
#[doc = "Port 1"]
pub mod port1;
#[doc = "Port 2"]
pub struct Port2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Port2 {}
impl Port2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const port2::RegisterBlock = 0x4802_8200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const port2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Port2 {
    type Target = port2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Port2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Port2").finish()
    }
}
#[doc = "Port 2"]
pub mod port2;
#[doc = "Port 3"]
pub struct Port3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Port3 {}
impl Port3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const port3::RegisterBlock = 0x4802_8300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const port3::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Port3 {
    type Target = port3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Port3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Port3").finish()
    }
}
#[doc = "Port 3"]
pub mod port3;
#[doc = "Port 4"]
pub struct Port4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Port4 {}
impl Port4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const port4::RegisterBlock = 0x4802_8400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const port4::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Port4 {
    type Target = port4::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Port4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Port4").finish()
    }
}
#[doc = "Port 4"]
pub mod port4;
#[doc = "Port 5"]
pub struct Port5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Port5 {}
impl Port5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const port5::RegisterBlock = 0x4802_8500 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const port5::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Port5 {
    type Target = port5::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Port5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Port5").finish()
    }
}
#[doc = "Port 5"]
pub mod port5;
#[doc = "Port 14"]
pub struct Port14 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Port14 {}
impl Port14 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const port14::RegisterBlock = 0x4802_8e00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const port14::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Port14 {
    type Target = port14::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Port14 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Port14").finish()
    }
}
#[doc = "Port 14"]
pub mod port14;
#[doc = "Port 15"]
pub struct Port15 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Port15 {}
impl Port15 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const port15::RegisterBlock = 0x4802_8f00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const port15::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for Port15 {
    type Target = port15::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Port15 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Port15").finish()
    }
}
#[doc = "Port 15"]
pub mod port15;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "PPB"]
    pub ppb: Ppb,
    #[doc = "DLR"]
    pub dlr: Dlr,
    #[doc = "ERU0"]
    pub eru0: Eru0,
    #[doc = "ERU1"]
    pub eru1: Eru1,
    #[doc = "GPDMA0"]
    pub gpdma0: Gpdma0,
    #[doc = "GPDMA0_CH0"]
    pub gpdma0_ch0: Gpdma0Ch0,
    #[doc = "GPDMA0_CH1"]
    pub gpdma0_ch1: Gpdma0Ch1,
    #[doc = "GPDMA0_CH2"]
    pub gpdma0_ch2: Gpdma0Ch2,
    #[doc = "GPDMA0_CH3"]
    pub gpdma0_ch3: Gpdma0Ch3,
    #[doc = "GPDMA0_CH4"]
    pub gpdma0_ch4: Gpdma0Ch4,
    #[doc = "GPDMA0_CH5"]
    pub gpdma0_ch5: Gpdma0Ch5,
    #[doc = "GPDMA0_CH6"]
    pub gpdma0_ch6: Gpdma0Ch6,
    #[doc = "GPDMA0_CH7"]
    pub gpdma0_ch7: Gpdma0Ch7,
    #[doc = "FCE"]
    pub fce: Fce,
    #[doc = "FCE_KE0"]
    pub fce_ke0: FceKe0,
    #[doc = "FCE_KE1"]
    pub fce_ke1: FceKe1,
    #[doc = "FCE_KE2"]
    pub fce_ke2: FceKe2,
    #[doc = "FCE_KE3"]
    pub fce_ke3: FceKe3,
    #[doc = "PBA0"]
    pub pba0: Pba0,
    #[doc = "PBA1"]
    pub pba1: Pba1,
    #[doc = "FLASH0"]
    pub flash0: Flash0,
    #[doc = "PREF"]
    pub pref: Pref,
    #[doc = "PMU0"]
    pub pmu0: Pmu0,
    #[doc = "WDT"]
    pub wdt: Wdt,
    #[doc = "RTC"]
    pub rtc: Rtc,
    #[doc = "SCU_CLK"]
    pub scu_clk: ScuClk,
    #[doc = "SCU_OSC"]
    pub scu_osc: ScuOsc,
    #[doc = "SCU_PLL"]
    pub scu_pll: ScuPll,
    #[doc = "SCU_GENERAL"]
    pub scu_general: ScuGeneral,
    #[doc = "SCU_INTERRUPT"]
    pub scu_interrupt: ScuInterrupt,
    #[doc = "SCU_PARITY"]
    pub scu_parity: ScuParity,
    #[doc = "SCU_TRAP"]
    pub scu_trap: ScuTrap,
    #[doc = "SCU_HIBERNATE"]
    pub scu_hibernate: ScuHibernate,
    #[doc = "SCU_POWER"]
    pub scu_power: ScuPower,
    #[doc = "SCU_RESET"]
    pub scu_reset: ScuReset,
    #[doc = "LEDTS0"]
    pub ledts0: Ledts0,
    #[doc = "SDMMC_CON"]
    pub sdmmc_con: SdmmcCon,
    #[doc = "SDMMC"]
    pub sdmmc: Sdmmc,
    #[doc = "ETH0_CON"]
    pub eth0_con: Eth0Con,
    #[doc = "ETH0"]
    pub eth0: Eth0,
    #[doc = "ECAT0_CON"]
    pub ecat0_con: Ecat0Con,
    #[doc = "ECAT0"]
    pub ecat0: Ecat0,
    #[doc = "ECAT0_FMMU0"]
    pub ecat0_fmmu0: Ecat0Fmmu0,
    #[doc = "ECAT0_FMMU1"]
    pub ecat0_fmmu1: Ecat0Fmmu1,
    #[doc = "ECAT0_FMMU2"]
    pub ecat0_fmmu2: Ecat0Fmmu2,
    #[doc = "ECAT0_FMMU3"]
    pub ecat0_fmmu3: Ecat0Fmmu3,
    #[doc = "ECAT0_FMMU4"]
    pub ecat0_fmmu4: Ecat0Fmmu4,
    #[doc = "ECAT0_FMMU5"]
    pub ecat0_fmmu5: Ecat0Fmmu5,
    #[doc = "ECAT0_FMMU6"]
    pub ecat0_fmmu6: Ecat0Fmmu6,
    #[doc = "ECAT0_FMMU7"]
    pub ecat0_fmmu7: Ecat0Fmmu7,
    #[doc = "ECAT0_SM0"]
    pub ecat0_sm0: Ecat0Sm0,
    #[doc = "ECAT0_SM1"]
    pub ecat0_sm1: Ecat0Sm1,
    #[doc = "ECAT0_SM2"]
    pub ecat0_sm2: Ecat0Sm2,
    #[doc = "ECAT0_SM3"]
    pub ecat0_sm3: Ecat0Sm3,
    #[doc = "ECAT0_SM4"]
    pub ecat0_sm4: Ecat0Sm4,
    #[doc = "ECAT0_SM5"]
    pub ecat0_sm5: Ecat0Sm5,
    #[doc = "ECAT0_SM6"]
    pub ecat0_sm6: Ecat0Sm6,
    #[doc = "ECAT0_SM7"]
    pub ecat0_sm7: Ecat0Sm7,
    #[doc = "USB0"]
    pub usb0: Usb0,
    #[doc = "USB0_EP0"]
    pub usb0_ep0: Usb0Ep0,
    #[doc = "USB0_EP1"]
    pub usb0_ep1: Usb0Ep1,
    #[doc = "USB0_EP2"]
    pub usb0_ep2: Usb0Ep2,
    #[doc = "USB0_EP3"]
    pub usb0_ep3: Usb0Ep3,
    #[doc = "USB0_EP4"]
    pub usb0_ep4: Usb0Ep4,
    #[doc = "USB0_EP5"]
    pub usb0_ep5: Usb0Ep5,
    #[doc = "USB0_EP6"]
    pub usb0_ep6: Usb0Ep6,
    #[doc = "USB0_CH0"]
    pub usb0_ch0: Usb0Ch0,
    #[doc = "USB0_CH1"]
    pub usb0_ch1: Usb0Ch1,
    #[doc = "USB0_CH2"]
    pub usb0_ch2: Usb0Ch2,
    #[doc = "USB0_CH3"]
    pub usb0_ch3: Usb0Ch3,
    #[doc = "USB0_CH4"]
    pub usb0_ch4: Usb0Ch4,
    #[doc = "USB0_CH5"]
    pub usb0_ch5: Usb0Ch5,
    #[doc = "USB0_CH6"]
    pub usb0_ch6: Usb0Ch6,
    #[doc = "USB0_CH7"]
    pub usb0_ch7: Usb0Ch7,
    #[doc = "USB0_CH8"]
    pub usb0_ch8: Usb0Ch8,
    #[doc = "USB0_CH9"]
    pub usb0_ch9: Usb0Ch9,
    #[doc = "USB0_CH10"]
    pub usb0_ch10: Usb0Ch10,
    #[doc = "USB0_CH11"]
    pub usb0_ch11: Usb0Ch11,
    #[doc = "USB0_CH12"]
    pub usb0_ch12: Usb0Ch12,
    #[doc = "USB0_CH13"]
    pub usb0_ch13: Usb0Ch13,
    #[doc = "USIC0"]
    pub usic0: Usic0,
    #[doc = "USIC1"]
    pub usic1: Usic1,
    #[doc = "USIC0_CH0"]
    pub usic0_ch0: Usic0Ch0,
    #[doc = "USIC0_CH1"]
    pub usic0_ch1: Usic0Ch1,
    #[doc = "USIC1_CH0"]
    pub usic1_ch0: Usic1Ch0,
    #[doc = "USIC1_CH1"]
    pub usic1_ch1: Usic1Ch1,
    #[doc = "CAN"]
    pub can: Can,
    #[doc = "CAN_NODE0"]
    pub can_node0: CanNode0,
    #[doc = "CAN_NODE1"]
    pub can_node1: CanNode1,
    #[doc = "CAN_MO"]
    pub can_mo: CanMo,
    #[doc = "VADC"]
    pub vadc: Vadc,
    #[doc = "VADC_G0"]
    pub vadc_g0: VadcG0,
    #[doc = "VADC_G1"]
    pub vadc_g1: VadcG1,
    #[doc = "DAC"]
    pub dac: Dac,
    #[doc = "CCU40"]
    pub ccu40: Ccu40,
    #[doc = "CCU41"]
    pub ccu41: Ccu41,
    #[doc = "CCU40_CC40"]
    pub ccu40_cc40: Ccu40Cc40,
    #[doc = "CCU40_CC41"]
    pub ccu40_cc41: Ccu40Cc41,
    #[doc = "CCU40_CC42"]
    pub ccu40_cc42: Ccu40Cc42,
    #[doc = "CCU40_CC43"]
    pub ccu40_cc43: Ccu40Cc43,
    #[doc = "CCU41_CC40"]
    pub ccu41_cc40: Ccu41Cc40,
    #[doc = "CCU41_CC41"]
    pub ccu41_cc41: Ccu41Cc41,
    #[doc = "CCU41_CC42"]
    pub ccu41_cc42: Ccu41Cc42,
    #[doc = "CCU41_CC43"]
    pub ccu41_cc43: Ccu41Cc43,
    #[doc = "CCU80"]
    pub ccu80: Ccu80,
    #[doc = "CCU80_CC80"]
    pub ccu80_cc80: Ccu80Cc80,
    #[doc = "CCU80_CC81"]
    pub ccu80_cc81: Ccu80Cc81,
    #[doc = "CCU80_CC82"]
    pub ccu80_cc82: Ccu80Cc82,
    #[doc = "CCU80_CC83"]
    pub ccu80_cc83: Ccu80Cc83,
    #[doc = "PORT0"]
    pub port0: Port0,
    #[doc = "PORT1"]
    pub port1: Port1,
    #[doc = "PORT2"]
    pub port2: Port2,
    #[doc = "PORT3"]
    pub port3: Port3,
    #[doc = "PORT4"]
    pub port4: Port4,
    #[doc = "PORT5"]
    pub port5: Port5,
    #[doc = "PORT14"]
    pub port14: Port14,
    #[doc = "PORT15"]
    pub port15: Port15,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            ppb: Ppb { _marker: PhantomData },
            dlr: Dlr { _marker: PhantomData },
            eru0: Eru0 { _marker: PhantomData },
            eru1: Eru1 { _marker: PhantomData },
            gpdma0: Gpdma0 { _marker: PhantomData },
            gpdma0_ch0: Gpdma0Ch0 { _marker: PhantomData },
            gpdma0_ch1: Gpdma0Ch1 { _marker: PhantomData },
            gpdma0_ch2: Gpdma0Ch2 { _marker: PhantomData },
            gpdma0_ch3: Gpdma0Ch3 { _marker: PhantomData },
            gpdma0_ch4: Gpdma0Ch4 { _marker: PhantomData },
            gpdma0_ch5: Gpdma0Ch5 { _marker: PhantomData },
            gpdma0_ch6: Gpdma0Ch6 { _marker: PhantomData },
            gpdma0_ch7: Gpdma0Ch7 { _marker: PhantomData },
            fce: Fce { _marker: PhantomData },
            fce_ke0: FceKe0 { _marker: PhantomData },
            fce_ke1: FceKe1 { _marker: PhantomData },
            fce_ke2: FceKe2 { _marker: PhantomData },
            fce_ke3: FceKe3 { _marker: PhantomData },
            pba0: Pba0 { _marker: PhantomData },
            pba1: Pba1 { _marker: PhantomData },
            flash0: Flash0 { _marker: PhantomData },
            pref: Pref { _marker: PhantomData },
            pmu0: Pmu0 { _marker: PhantomData },
            wdt: Wdt { _marker: PhantomData },
            rtc: Rtc { _marker: PhantomData },
            scu_clk: ScuClk { _marker: PhantomData },
            scu_osc: ScuOsc { _marker: PhantomData },
            scu_pll: ScuPll { _marker: PhantomData },
            scu_general: ScuGeneral { _marker: PhantomData },
            scu_interrupt: ScuInterrupt { _marker: PhantomData },
            scu_parity: ScuParity { _marker: PhantomData },
            scu_trap: ScuTrap { _marker: PhantomData },
            scu_hibernate: ScuHibernate { _marker: PhantomData },
            scu_power: ScuPower { _marker: PhantomData },
            scu_reset: ScuReset { _marker: PhantomData },
            ledts0: Ledts0 { _marker: PhantomData },
            sdmmc_con: SdmmcCon { _marker: PhantomData },
            sdmmc: Sdmmc { _marker: PhantomData },
            eth0_con: Eth0Con { _marker: PhantomData },
            eth0: Eth0 { _marker: PhantomData },
            ecat0_con: Ecat0Con { _marker: PhantomData },
            ecat0: Ecat0 { _marker: PhantomData },
            ecat0_fmmu0: Ecat0Fmmu0 { _marker: PhantomData },
            ecat0_fmmu1: Ecat0Fmmu1 { _marker: PhantomData },
            ecat0_fmmu2: Ecat0Fmmu2 { _marker: PhantomData },
            ecat0_fmmu3: Ecat0Fmmu3 { _marker: PhantomData },
            ecat0_fmmu4: Ecat0Fmmu4 { _marker: PhantomData },
            ecat0_fmmu5: Ecat0Fmmu5 { _marker: PhantomData },
            ecat0_fmmu6: Ecat0Fmmu6 { _marker: PhantomData },
            ecat0_fmmu7: Ecat0Fmmu7 { _marker: PhantomData },
            ecat0_sm0: Ecat0Sm0 { _marker: PhantomData },
            ecat0_sm1: Ecat0Sm1 { _marker: PhantomData },
            ecat0_sm2: Ecat0Sm2 { _marker: PhantomData },
            ecat0_sm3: Ecat0Sm3 { _marker: PhantomData },
            ecat0_sm4: Ecat0Sm4 { _marker: PhantomData },
            ecat0_sm5: Ecat0Sm5 { _marker: PhantomData },
            ecat0_sm6: Ecat0Sm6 { _marker: PhantomData },
            ecat0_sm7: Ecat0Sm7 { _marker: PhantomData },
            usb0: Usb0 { _marker: PhantomData },
            usb0_ep0: Usb0Ep0 { _marker: PhantomData },
            usb0_ep1: Usb0Ep1 { _marker: PhantomData },
            usb0_ep2: Usb0Ep2 { _marker: PhantomData },
            usb0_ep3: Usb0Ep3 { _marker: PhantomData },
            usb0_ep4: Usb0Ep4 { _marker: PhantomData },
            usb0_ep5: Usb0Ep5 { _marker: PhantomData },
            usb0_ep6: Usb0Ep6 { _marker: PhantomData },
            usb0_ch0: Usb0Ch0 { _marker: PhantomData },
            usb0_ch1: Usb0Ch1 { _marker: PhantomData },
            usb0_ch2: Usb0Ch2 { _marker: PhantomData },
            usb0_ch3: Usb0Ch3 { _marker: PhantomData },
            usb0_ch4: Usb0Ch4 { _marker: PhantomData },
            usb0_ch5: Usb0Ch5 { _marker: PhantomData },
            usb0_ch6: Usb0Ch6 { _marker: PhantomData },
            usb0_ch7: Usb0Ch7 { _marker: PhantomData },
            usb0_ch8: Usb0Ch8 { _marker: PhantomData },
            usb0_ch9: Usb0Ch9 { _marker: PhantomData },
            usb0_ch10: Usb0Ch10 { _marker: PhantomData },
            usb0_ch11: Usb0Ch11 { _marker: PhantomData },
            usb0_ch12: Usb0Ch12 { _marker: PhantomData },
            usb0_ch13: Usb0Ch13 { _marker: PhantomData },
            usic0: Usic0 { _marker: PhantomData },
            usic1: Usic1 { _marker: PhantomData },
            usic0_ch0: Usic0Ch0 { _marker: PhantomData },
            usic0_ch1: Usic0Ch1 { _marker: PhantomData },
            usic1_ch0: Usic1Ch0 { _marker: PhantomData },
            usic1_ch1: Usic1Ch1 { _marker: PhantomData },
            can: Can { _marker: PhantomData },
            can_node0: CanNode0 { _marker: PhantomData },
            can_node1: CanNode1 { _marker: PhantomData },
            can_mo: CanMo { _marker: PhantomData },
            vadc: Vadc { _marker: PhantomData },
            vadc_g0: VadcG0 { _marker: PhantomData },
            vadc_g1: VadcG1 { _marker: PhantomData },
            dac: Dac { _marker: PhantomData },
            ccu40: Ccu40 { _marker: PhantomData },
            ccu41: Ccu41 { _marker: PhantomData },
            ccu40_cc40: Ccu40Cc40 { _marker: PhantomData },
            ccu40_cc41: Ccu40Cc41 { _marker: PhantomData },
            ccu40_cc42: Ccu40Cc42 { _marker: PhantomData },
            ccu40_cc43: Ccu40Cc43 { _marker: PhantomData },
            ccu41_cc40: Ccu41Cc40 { _marker: PhantomData },
            ccu41_cc41: Ccu41Cc41 { _marker: PhantomData },
            ccu41_cc42: Ccu41Cc42 { _marker: PhantomData },
            ccu41_cc43: Ccu41Cc43 { _marker: PhantomData },
            ccu80: Ccu80 { _marker: PhantomData },
            ccu80_cc80: Ccu80Cc80 { _marker: PhantomData },
            ccu80_cc81: Ccu80Cc81 { _marker: PhantomData },
            ccu80_cc82: Ccu80Cc82 { _marker: PhantomData },
            ccu80_cc83: Ccu80Cc83 { _marker: PhantomData },
            port0: Port0 { _marker: PhantomData },
            port1: Port1 { _marker: PhantomData },
            port2: Port2 { _marker: PhantomData },
            port3: Port3 { _marker: PhantomData },
            port4: Port4 { _marker: PhantomData },
            port5: Port5 { _marker: PhantomData },
            port14: Port14 { _marker: PhantomData },
            port15: Port15 { _marker: PhantomData },
        }
    }
}
